"use strict";(self["webpackChunkfinal_site"]=self["webpackChunkfinal_site"]||[]).push([[234],{234:function(e,a,t){t.r(a),t.d(a,{default:function(){return x}});var l=t(3396);const n={class:"chapter-container"},i={class:"chapter-article"},r=(0,l.uE)("<h3>類別與物件的基本概念</h3><p> 所謂物件,說得白話一點,可稱之為&quot;東西&quot;。這是個很抽象的名詞,我們若以它具體的特性來描述,會比較清楚: </p><ul><li>Object有生命週期,會&quot;產生&quot;和&quot;消滅&quot;</li><li> Object具有其內部狀態, 同一類別的不同Object, 其的內部狀態可能都不一樣 </li><li> Object可以接收&quot;訊息&quot;,並依據訊息的參數以及該物件的內部狀態,做出反應,並可能因而改變該物件的內部狀態 </li></ul><p> 屬於同一個Class的Object,會具有該Class所定義的以上三種特質。 </p><p> 除此之外,Class之間可以定義繼承(Inheritance)關係,子類別(Sub Class)繼承父類別(Super Class)的所有特性,子類別還可以定義其專屬的特性。 </p><p> 以Object-Oriented(物件導向) Language寫作程式時,寫作的主體是Class。Class定義了所有屬於該Class的Object的特性,這些特性可分類如下: </p><ul><li> Object產生時一定要呼叫的方法, 稱為Constructor(建構子) </li><li> Object消滅需要呼叫的方法, 稱為Destructor(解構子) </li><li> 表達Object內部狀態的變數, 稱為Object Variable(物件變數成員) </li><li> Object可以接收的訊息, 稱為Object Method(物件方法成員) </li><li>上述兩個可總稱為Object Member</li><li>屬於Class的變數, 稱為Class Variable(類別變數)</li><li>屬於Class的方法, 成為Class Method(類別方法)</li><li>上述兩個可總稱為Class Member</li><li>和其他Class間的繼承關係</li></ul><h3>如何以Java撰寫類別</h3><p> Java規定公共類別(public class)必須寫在該公共類別名稱的.java檔案內, 例如public class Example就必須寫在Example.java這個檔案內。Example.java裡面也可以定義其他的類別,但是只有class Example能夠宣告為public,其他Example.java裡的class都不能宣告為public。當Java Virtual Machine啟動時,它會去找命令列上所指定的class裡的public static void main(String[] argv)方法,當做是程式的進入點。這有點像是C語言的main, 不同處在於每個java class都可以定義自己的public static void main(String[] argv)。 </p>",9),c=(0,l._)("p",null," 啟動上述的JVM時, JVM會去執行class Example裡的public static void main(String[] argv)。以下範例Example.java說明如何定義Java的class。 ",-1),s=(0,l.uE)("<p>上述例子裡所用到的關鍵字或類別名稱說明如下:</p><ul><li> public:可用在 <ul><li> class前面表示此class可以供其他package裡的類別使用。同一個目錄下的class均可視為屬於同一個package。 </li><li> object or class member前面, 表示所有的class均可存取此member。 </li></ul></li><li> private:可用在object or class member前面, 表示只有定義這些member的class才可存取。 </li><li> static:可用在member前面。如果member前面有static, 表示該member屬於class,否則屬於object。不論系統創造了多少object,class variable只有一個;而每個object都有其object variable。存取class method的語法是ClassName.classMethod();存取object method時,則必須以reference.objectMethod()來呼叫。在Object Method裡,可用this表示目前的物件。但在Class Method裡就不能存取object member了。 </li><li>this:表示目前這個物件</li><li> String:定義於java.lang package下面的類別, 屬於Java語言定義的標準程式庫。 </li><li> System:定義於java.lang package下面的類別, 屬於Java語言定義的標準程式庫。 </li><li> System.out是class System裡面的一個Class Variable, 其型態為reference to 定義於java.io package裡面的PrintStream。我們可透過該變數所指到的物件, 將訊息印到螢幕上。 </li><li> System.gc是class System裡面的一個Class Method, 呼叫該方法可強迫JVM回收沒有被任何reference指到的物件。當物件被回收時, 該物件的finalize方法會被呼叫。 </li><li> new:用來產生新的物件。後面必須跟著某個constructor, 以便進行初始化的動作。 </li></ul><h3> Object Method的名稱如果和Class的名稱相同, 則表示該Method為Constructor。Constructor不能宣告傳回值。 </h3><p> 要附帶說明的是, Java以new指令來產生物件, 但不像C++有提供相對應的delete指令來消滅物件。Java採用Garbage Collection的觀念,當系統於閒置期間自動呼叫或由使用者強制呼叫System.gc()時,沒有被任何reference指到的Object就會被回收。 </p><p> Class裡面一定要定義一個以上的Constructor, 但為了方便起見,如果Compiler發現某Class沒有定義Constructor,則Compiler會幫我們產生一個不做任何事的Constructor: </p>",5),o=(0,l._)("p",null,"就相當於",-1),u=(0,l._)("h3",null,"Overloading",-1),d=(0,l._)("p",null," 同一個class裡的Method名稱可以重複使用,只要可以由Method的參數個數和型態來區分就可以了。這種觀念稱為overloading。 ",-1),p=(0,l._)("p",null," 不只一般的method可以overloading, constructor也可以overloading。 ",-1),b=(0,l._)("p",null," 上面的例子裡說明constructor也可以overloading。要特別注意的是,傳回值並不能用來分辨要呼叫哪個method,因此若再加上public int print()的宣告,就會造成編譯錯誤了。 ",-1),h=(0,l._)("h3",null,"初始化的執行順序",-1),v=(0,l._)("p",null," Class variable是在該類別載入JVM時進行初始化的, 因此寫作上經常在class variable的宣告後面加上初始化的動作。對Object Variable來說, 是在產生Object時進行初始化的, 但初始化的步驟可以寫在變數宣告後, 也可以寫在constructor內, 因此必須對其執行順序有所了解。步驟如下: ",-1),m=(0,l._)("ol",null,[(0,l._)("li",null," 先將所有變數設為內定值。對數值型態來說, 其值為0;對reference來說, 其值為null;對boolean來說, 其值為false。 "),(0,l._)("li",null,"呼叫父類別的constructor。"),(0,l._)("li",null,"執行變數宣告的初始化動作。"),(0,l._)("li",null,"執行自己的constructor。")],-1),g=(0,l._)("p",null,"因此在如下的範例內",-1),j=(0,l._)("p",null,"data的變化如下",-1),C=(0,l._)("ol",null,[(0,l._)("li",null,"設為內定值0"),(0,l._)("li",null," 呼叫父類別的Constructor。因為類別InitSequence沒有宣告繼承任何類別, Java規定此情況會自動繼承java.lang.Object這個類別。Object的Constructor不做任何事。 "),(0,l._)("li",null,"執行變數宣告的初始動作,成為2"),(0,l._)("li",null,"執行自己的constructor,成為3")],-1),S=(0,l._)("p",null,"因此最後執行的結果會在螢幕上印出數字3。",-1),f=(0,l._)("p",null,"Java語言還可以定義static block:",-1),O=(0,l._)("p",null," static block內的程式碼, 是在該class載入JVM之後, 進行class variable初始化之前的時間內執行。一般比較會使用static block的場合, 是該class用到一些非Java的程式庫, 需要透過System.loadLibrary(String libName)方法把外界的程式碼載入時。這樣寫的好處是只有當該class第一次被使用到時, 才會下載相關軟體, 以節省記憶體空間, 避免重複下載, 並可以把實作的細節和外界隔離開來。對沒有這種機制的C語言來說, 很可能就必須在主程式內寫上一堆很難懂的啟動程式碼。 ",-1),V=(0,l._)("h3",null,"final關鍵字",-1),M=(0,l._)("p",null," final關鍵字用在變數宣告時,表示該變數的值只能在宣告時給定,然後就不能再更改了。 ",-1);function _(e,a,t,_,y,w){const J=(0,l.up)("highlightjs"),k=(0,l.up)("TableOfContentSidebar");return(0,l.wg)(),(0,l.iD)("div",n,[(0,l._)("div",i,[r,(0,l.Wm)(J,{class:"code-container",autodetect:"",code:"java Example"}),c,(0,l.Wm)(J,{class:"code-container",language:"java",code:'class Vehicle {\r\n    private int speed; // Object Variable\r\n    private String direction; // Object Variable, direction is a reference to String Object\r\n    private static int numVehicle = 0; // Class Variable\r\n    public Vehicle() { // Constructor, called when new a Object\r\n        this(0,"north"); // call another constructor to do initialization\r\n    }\r\n    public Vehicle(int s, String dir) { // Another Constructor. Use overloading to define two constructors\r\n        float speed; // define a local variable\r\n        speed = s; // the speed here refers to the above local variable\r\n        this.speed = s; // If we want to set object variable, use this.speed to refer object variable speed\r\n        direction = dir; // dir is a reference to object, not the object itself\r\n        numVehicle++;   // increase the Vehicle number\r\n    }\r\n    protected void finalize() { // Destructor, called when the object is garbage collected by JVM\r\n        System.out.println("finalize has been called");\r\n        numVehicle--;\r\n    }\r\n    void setSpeed(int newSpeed) { // Object Method\r\n        this.speed = newSpeed;\r\n    }\r\n    void setDir(String dir) { // Object Method\r\n        this.direction = dir;\r\n    }\r\n    int getSpeed() { // Object Method\r\n        return speed;\r\n    }\r\n    String getDir() { // Object Method\r\n        return direction;\r\n    }\r\n    public static int totalVehicle() { // Class Method\r\n        return numVehicle;\r\n    }\r\n}\r\npublic class Example {\r\n    public static void main(String[] argv) {\r\n        Vehicle v1 = new Vehicle(50, "west"); // new 敘述用來產生物件. 物件產生時需要呼叫Constructor來初始化物件\r\n        Vehicle v2;\r\n        v1.setSpeed(30);\r\n        v1.setDir("north");\r\n        System.out.println("V1: speed is "+v1.getSpeed()+", direction is "+v1.getDir()+".\\n");\r\n        v2 = new Vehicle(40, "south");\r\n        System.out.println("There are "+Vehicle.totalVehicle()+" Vehicles in the world.\\n");\r\n        v1 = v2; // let reference v1 point to where v2 is pointing\r\n        System.out.println("V1: speed is "+v1.getSpeed()+", direction is "+v1.getDir()+".\\n");\r\n        System.gc(); // force system to do garbage collection, the object previously pointed by v1 shall be destroyed\r\n        System.out.println("There are "+Vehicle.totalVehicle()+" Vehicles in the world.\\n");\r\n    }\r\n}'}),s,(0,l.Wm)(J,{class:"code-container",language:"java",code:"public class A {\r\n}"}),o,(0,l.Wm)(J,{class:"code-container",language:"java",code:"public class A {\r\n    public A() {}\r\n}"}),u,d,p,(0,l.Wm)(J,{class:"code-container",language:"java",code:"public class Overloading {\r\n    int data;\r\n    public Overloading() {\r\n        this(0); // call constructor Overloading(int)\r\n    }\r\n    public Overloading(int data) {\r\n        this.data = data;\r\n    }\r\n    public void print() {\r\n        this.print(0); // call method print(int)\r\n    }\r\n    public void print(int msg) {\r\n    }\r\n    public void print(float msg) {\r\n    }\r\n    public void print(int msg, String others) {\r\n    }\r\n}"}),b,h,v,m,g,(0,l.Wm)(J,{class:"code-container",language:"java",code:"public class InitSequence {\r\n    int data = 2;\r\n    public InitSequence(int data) {\r\n        this.data = data;\r\n    }\r\n    public static void main(String[] argv) {\r\n        InitSequence s = new InitSequence(3);\r\n        System.out.println(s.data);\r\n    }\r\n}"}),j,C,S,f,(0,l.Wm)(J,{class:"code-container",language:"java",code:"public class StaticBlock {\r\n    static { // this is a static block\r\n        data = (int)(Math.random()*100);\r\n    }\r\n    static int data;\r\n    public static void main(String[] argv) {\r\n        System.out.println(data);\r\n    }\r\n}"}),O,(0,l.Wm)(J,{class:"code-container",language:"java",code:'class ClassNeedToLoadLibrary {\r\n    static {\r\n        System.loadLibrary("mylib");\r\n    }\r\n}\r\npublic class Main {\r\n    public static void main(String[] argv) {\r\n    }\r\n}'}),V,M,(0,l.Wm)(J,{class:"code-container",language:"java",code:"public class Main {\r\n    public static final double PI = 3.14159;\r\n    public final int x = 10;\r\n    public static void main(String[] argv) {\r\n        final int local = 10;\r\n        Main m = new Main();\r\n        PI = 100; // Compile Error, final variable can only be set at initialization\r\n        m.x = 10; // Compile Error\r\n        local = 100; // Compile Error\r\n    }\r\n}"})]),(0,l.Wm)(k,{allHeaders:e.allHeaders},null,8,["allHeaders"])])}var y=t(6569),w=t(762),J=t(5124),k={name:"J_Chapter2",components:{highlightjs:w.Z.component,TableOfContentSidebar:y.Z,HeaderTemplate:J.Z}},E=t(89);const q=(0,E.Z)(k,[["render",_]]);var x=q}}]);
//# sourceMappingURL=234.f257e9a7.js.map